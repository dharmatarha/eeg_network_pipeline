function circleGraphPlotWrapper(connFile, connVar, moduleFile, moduleVar, colorFile, roiFile, targetDir)
%% Wrapper for calling circleGraphPlot on a set of connectivity matrices
% E.g. plotting all epochs in a subject's data. 
%
% USAGE circleGraphPlotWrapper(connFile, connVar, moduleFile, moduleVar, colorFile, roiFile, targetDir)
%
% It save all plots generated by circleGraphPlot out in png format to
% "targetDir". 
%
% Inputs:
% connFile      - String, path to a file containing the relevant
%           connectivity array. Typically the output of edgePruning.m or 
%           getMeanConn.m (the later performed on a set of edgePruning.m 
%           results) 
% connVar       - String, name of the connectivity array variable. The
%           array, as with other functions in this repo, is expected to
%           contain a set of connectivity matrices, each defined by the
%           first two dimensions. Third and fourth dimensions are expected
%           to refer to epochs and conditions (stimuli). 
% moduleFile    - String, path to a file containing the modules identified
%           in the connectivity array "connVar".  
% moduleVar     - String, name of the module indices array. Expected to be
%               a numerical array with the first dimension matching the 
%               number of nodes/ROIs, the second and third dimension the 
%               epochs and conditions (stimuli).
% colorFile     - String, path to file containing a "colorTriplets" matrix
%               variable. The matrix is expected to have three columns,
%               with each row defining an RGB color. Used for highlighting
%               different modules in plots.
% roiFile     - String, path to file containing a "rois" cell array
%               variable holding the node/ROI labels. 
% targetDir     - String, path to a folder, used for saving out all
%               generated plots.
%
%
%



%% Input checks

if nargin ~= 7
    error(['Function circleGraphPlotWrapper requires seven input args: ',...
        '"connFile", "connVar", "moduleFile", "moduleVar", "colorFile", ',...
        '"roiFile" and "targetDir"']);
end
if ~exist(connFile, 'file')
    error('Input arg "connFile" is not a valid file path!');
end
if ~exist(moduleFile, 'file')
    error('Input arg "moduleFile" is not a valid file path!');
end
if ~exist(colorFile, 'file')
    error('Input arg "colorFile" is not a valid file path!');
end
if ~exist(roiFile, 'file')
    error('Input arg "roiFile" is not a valid file path!');
end
if ~exist(targetDir, 'dir')
    error('Input arg "targetDir" is not a valid directory path!');
end
if ~ischar(connVar)
    error('Input arg "connVar" should be a string (variable name)!');
end
if ~ischar(moduleVar)
    error('Input arg "moduleVar" should be a string (variable name)!');
end

% user message
disp([char(10), 'Function circleGraphPlotWrapper is called with inputs: ',...
    char(10), 'File for the connectivity data: ', connFile,...
    char(10), 'Variable to load from connectivity data file: ', connVar,...
    char(10), 'File for module indices: ', moduleFile,...
    char(10), 'Variable to load from module indices file: ', moduleVar,...
    char(10), 'RGB color file ', colorFile,...
    char(10), 'ROI/node labels file: ', roiFile,...
    char(10), 'Target dir for saving figures: ', targetDir]);


%% Load data + module indices + colors

% connectivity data
data = load(connFile, connVar);
connData = data.(connVar});
% module indices / node memberships
modules = load(moduleFile, moduleVar);
modIndices = modules.(moduleVar);
% colors and ROI/node labels
load(colorFile, 'colorTriplets');
load(roiFile, 'rois'); labels = rois;

% sanity checks
if ~isequal(size(connData, 1), size(connData, 2))
    error('First two dimension of connectivity array should be equal (square matrix per epoch)!');
end
if ~isequal(size(modIndices, 1), size(connData, 1))
    error('First dimension of module array does not match first dimension of connectivity data array!');
end
if ~isequal(length(rois), size(connData, 1))
    error('Number of ROI/node labels supplied does not match the number of nodes in connectivity data array (its first dimension)!');
end

% user message about supplied data and module indices
disp([char(10), 'Loaded connectivity data, with size ', num2str(connData),...
    char(10), 'Loaded module indices, with size ', num2str(modIndices),...
    char(10), 'Loaded RGB colors for module highlighting, with ', num2str(size(colorTriplets, 1)), ' RGB triplets',...
    char(10), 'Loaded ROI/node labels, with ', num2str(length(labels)), ' elements.'])


%% New ROI/node labels in special case
% For a specific set of ROI/node labels we transform the data for 
% better plots

% expected set of labels
newLabels = {'lateralorbitofrontal L', 'medialorbitofrontal L', 'parsorbitalis L', 'parstriangularis L', 'parsopercularis L', 'rostralmiddlefrontal L', 'caudalmiddlefrontal L', 'superiorfrontal L', 'precentral L',...
    'rostralanteriorcingulate L', 'caudalanteriorcingulate L', 'posteriorcingulate L', 'isthmuscingulate L',...
    'transversetemporal L', 'superiortemporal L', 'middletemporal L', 'inferiortemporal L', 'entorhinal L', 'parahippocampal L', 'fusiform L', 'insula L',...
    'supramarginal L', 'inferiorparietal L', 'superiorparietal L', 'postcentral L', 'paracentral L', 'precuneus L',...
    'cuneus L', 'lingual L', 'pericalcarine L', 'lateraloccipital L',...
    'lateraloccipital R', 'pericalcarine R', 'lingual R', 'cuneus R',...
    'precuneus R', 'paracentral R', 'postcentral R', 'superiorparietal R', 'inferiorparietal R', 'supramarginal R',...
    'insula R', 'fusiform R', 'parahippocampal R', 'entorhinal R', 'inferiortemporal R', 'middletemporal R', 'superiortemporal R', 'transversetemporal R',...
    'isthmuscingulate R', 'posteriorcingulate R', 'caudalanteriorcingulate R', 'rostralanteriorcingulate R',...
    'precentral R', 'superiorfrontal R', 'caudalmiddlefrontal R', 'rostralmiddlefrontal R', 'parsopercularis R', 'parstriangularis R', 'parsorbitalis R', 'medialorbitofrontal R', 'lateralorbitofrontal R',...
    };
shiftLabels = 15;
newLabels = [newLabels(end-shiftLabels:end), newLabels(1:end-shiftLabels-1)];

% get intersect of supplied labels and expected ones
c = intersect(labels, newLabels);

% if the two sets match, set data transformation flag
if isequal(c, labels)
    transformFlag = 1;  % transformation flag
else
    transformFlag = 0;
end

% user message
if transformFlag
    disp([char(10), 'The label set enables lobule highlighting in main figures.']);
else
    disp([char(10), 'The label set does not enable lobule highlighting in main figures.']);
end


%% Condition (stimulus) and epoch loops



% basic data
meanConnFile = '/home/adamb/eeg_network_pipeline/dev/edgePruningResults/alpha/avg_alpha_edgePruningInfo.mat';
membershipFile = '/home/adamb/eeg_network_pipeline/dev/edgePruningResults/alpha/avg_alpha_edgePruningInfo_modules.mat';
colorFile = '/home/adamb/eeg_network_pipeline/utils/colorTriplets.mat';
load(meanConnFile, 'prunedConnAvg');
load(membershipFile, 'memberships');
load(colorFile, 'colorTriplets');

% select graph (and corresponding memberships)
epochIdx = 1;
condIdx = 1;
g = prunedConnAvg(:, :, epochIdx, condIdx);
m = memberships(:, epochIdx, condIdx);

% load labels / ROI names
rois = '/home/adamb/eeg_network_pipeline/utils/roiNamesInOrder.mat';
l = load(rois); labels = l.roisShort;


% newLabels = {'lateralorbitofrontal L', 'medialorbitofrontal L', 'parsorbitalis L', 'parstriangularis L', 'parsopercularis L', 'rostralmiddlefrontal L', 'caudalmiddlefrontal L', 'superiorfrontal L', 'precentral L',...
%     'lateralorbitofrontal R', 'medialorbitofrontal R', 'parsorbitalis R', 'parstriangularis R', 'parsopercularis R', 'rostralmiddlefrontal R', 'caudalmiddlefrontal R', 'superiorfrontal R', 'precentral R',...
%     'rostralanteriorcingulate L', 'caudalanteriorcingulate L', 'posteriorcingulate L', 'isthmuscingulate L',... 
%     'rostralanteriorcingulate R', 'caudalanteriorcingulate R', 'posteriorcingulate R', 'isthmuscingulate R',...
%     'transversetemporal L', 'superiortemporal L', 'middletemporal L', 'inferiortemporal L', 'entorhinal L', 'parahippocampal L', 'fusiform L', 'insula L',...
%     'transversetemporal R', 'superiortemporal R', 'middletemporal R', 'inferiortemporal R', 'entorhinal R', 'parahippocampal R', 'fusiform R', 'insula R',...
%     'supramarginal L', 'inferiorparietal L', 'superiorparietal L', 'postcentral L', 'paracentral L', 'precuneus L',...
%     'supramarginal R', 'inferiorparietal R', 'superiorparietal R', 'postcentral R', 'paracentral R', 'precuneus R',...
%     'lateraloccipital L', 'pericalcarine L', 'lingual L', 'cuneus L',...
%     'lateraloccipital R', 'pericalcarine R', 'lingual R', 'cuneus R'};

newLabels = {'lateralorbitofrontal L', 'medialorbitofrontal L', 'parsorbitalis L', 'parstriangularis L', 'parsopercularis L', 'rostralmiddlefrontal L', 'caudalmiddlefrontal L', 'superiorfrontal L', 'precentral L',...
    'rostralanteriorcingulate L', 'caudalanteriorcingulate L', 'posteriorcingulate L', 'isthmuscingulate L',...
    'transversetemporal L', 'superiortemporal L', 'middletemporal L', 'inferiortemporal L', 'entorhinal L', 'parahippocampal L', 'fusiform L', 'insula L',...
    'supramarginal L', 'inferiorparietal L', 'superiorparietal L', 'postcentral L', 'paracentral L', 'precuneus L',...
    'cuneus L', 'lingual L', 'pericalcarine L', 'lateraloccipital L',...
    'lateraloccipital R', 'pericalcarine R', 'lingual R', 'cuneus R',...
    'precuneus R', 'paracentral R', 'postcentral R', 'superiorparietal R', 'inferiorparietal R', 'supramarginal R',...
    'insula R', 'fusiform R', 'parahippocampal R', 'entorhinal R', 'inferiortemporal R', 'middletemporal R', 'superiortemporal R', 'transversetemporal R',...
    'isthmuscingulate R', 'posteriorcingulate R', 'caudalanteriorcingulate R', 'rostralanteriorcingulate R',...
    'precentral R', 'superiorfrontal R', 'caudalmiddlefrontal R', 'rostralmiddlefrontal R', 'parsopercularis R', 'parstriangularis R', 'parsorbitalis R', 'medialorbitofrontal R', 'lateralorbitofrontal R',...
    };


shiftLabels = 15;
newLabels = [newLabels(end-shiftLabels:end), newLabels(1:end-shiftLabels-1)];

% create symmetric adjacency matrix with zeros at diagonal
g = triu(g, 1) + triu(g, 1)';
g(isnan(g)) = 0;

[gNew, old2new] = matrixReorder(g, l.rois, newLabels);

g = gNew;
labels = newLabels;
m = m(old2new);

connMatrix = g; membership = m;

% trimmingThr = [0.1, 0.3];

% % just for plotting we set low values to zero
% g(g<0.2) = 0;  



% get colors to modules
moduleIndices = unique(m);
colorMap = zeros(length(m), 3);
for i = 1:length(moduleIndices)
    colorMap(m==moduleIndices(i), :) = repmat(colorTriplets(i, :), [sum(m==moduleIndices(i)), 1]);
end


% % draw circular network figure
% circularGraph(g,'Colormap', colorMap,'Label',labels);

% create built-in graph object
G = graph(g, labels, 'upper');
% edge weights into vector
weights = G.Edges.Weight;
% edge ending nodes into cell array
nodesPerEdge = G.Edges.EndNodes;

% go through all modules, set different edge properties per module
edgeColors = repmat([0.5, 0.5, 0.5], [size(weights, 1), 1]);  % preallocate variable for edge color, filled with "gray"
edgeWidth = weights;
moduleEdges = zeros(size(weights, 1), length(moduleIndices));
for i = 1:length(moduleIndices)
    moduleNodes = labels(m == moduleIndices(i));
    moduleEdges(:, i) = ismember(nodesPerEdge(:, 1), moduleNodes) & ismember(nodesPerEdge(:, 2), moduleNodes);
    edgeColors(logical(moduleEdges(:, i)), :) = repmat(colorTriplets(i, :), [sum(moduleEdges(:, i)), 1]);
    edgeWidth(logical(moduleEdges(:, i))) = weights(logical(moduleEdges(:, i)))*10;
end

outModEdgeIdx = ismember(edgeColors, [0.5, 0.5, 0.5], 'rows');
edgeStyle = repmat({'-'}, [size(weights, 1), 1]);
edgeStyle(outModEdgeIdx) = repmat({'none'}, [sum(outModEdgeIdx, 1), 1]);

% create base graph plot
H = G.plot('Layout', 'circle',... 
    'LineWidth', edgeWidth,... 
    'EdgeColor', edgeColors,... 
    'EdgeAlpha', 0.3,... 
    'NodeColor', colorMap,...
    'MarkerSize', 10,...
    'LineStyle', edgeStyle);

% highlight a module
% nodes
modNodes = labels(m==0);
highlight(H, modNodes, 'MarkerSize', 10, 'NodeColor', colorTriplets(2,:));
% edges
% get edge indices for connections inside the module
modG = subgraph(G, modNodes);
subgNodes = modG.Edges.EndNodes;
subgWeights = modG.Edges.Weight;
for subedge = 1:size(subgNodes, 1)
    highlight(H, subgNodes(subedge, 1), subgNodes(subedge, 2), 'LineWidth', subgWeights(subedge)*12, 'EdgeColor', colorTriplets(2,:));
end



