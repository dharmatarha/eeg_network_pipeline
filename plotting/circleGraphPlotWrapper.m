function circleGraphPlotWrapper(connFile, connVar, moduleFile, moduleVar, colorFile, roiFile, roiVar, targetDir, varargin)
%% Wrapper for calling circleGraphPlot on a set of connectivity matrices
% E.g. plotting all epochs in a subject's data. 
%
% USAGE circleGraphPlotWrapper(connFile, 
%                               connVar, 
%                               moduleFile, 
%                               moduleVar, 
%                               colorFile, 
%                               roiFile, 
%                               roiVar,
%                               targetDir, 
%                               trimmingThr=[0.2, 0.3],... 
%                               drawFlag=1, 
%                               titleBase=[])
%
% It saves all plots generated by circleGraphPlot out in png format to
% "targetDir". Optional inputs are passed on to circleGraphPlot at each
% function call. 
%
% Mandatory inputs:
% connFile      - Char array, path to a file containing the relevant
%           connectivity array. Typically some output of edgePruning.m or 
%           getMeanConn.m.
% connVar       - Char array, name of the connectivity array variable. The
%           array is expected to be numeric, 3D or 4D, containing a set of 
%           connectivity matrices, each defined by the first two 
%           dimensions. Third and optional fourth dimensions are expected
%           to refer to layers/epochs and conditions (stimuli), respectively. 
% moduleFile    - Char array, path to a file containing the modules identified
%           in the connectivity array "connVar".  
% moduleVar     - Char array, name of the module indices array variable in 
%           "moduleFile". A numerical array with the first dimension matching 
%           the number of nodes/ROIs, the second and optional third 
%           dimensions the epochs and conditions (stimuli).
% colorFile     - Char array, path to file containing a "colorTriplets" 
%           numeric matrix variable. The matrix is expected to have 
%           three columns, with each row defining an RGB color. 
%           Used for highlighting different modules in plots.
% roiFile     - Char array, path to file containing a cell array
%           variable holding the node/ROI labels.
% roiVar      - Char array, name of the cell array variable holding the
%           node/ROI labels. 
% targetDir     - Char array, path to a folder, used for saving out all
%           generated plots.
%
%
% Optional inputs:
% trimmingThr   - Numeric vector with one or two elements. Edge trimming 
%           treshold that is passed on to circleGraphPlot. Value(s)
%           must be in range [0:0.01:0.9]. Defaults to [0.2, 0.3].
% drawFlag      - Char array, one of {'draw', 'nodraw'}. Passed on to circleGraphPlot.
%           Flag for displaying the plot (='draw') or only returning 
%           the plot object handle ('nodraw'). Defaults to 'draw' (display plot).
% titleBase     - Char array, title text for each figure generated. "titleBase"
%           is always amended by the epoch and condition number. Defaults to
%           [].
%
%



%% Input checks

if ~ismember(nargin, 8:11)
    error(['Function circleGraphPlotWrapper requires input args: ',...
        '"connFile", "connVar", "moduleFile", "moduleVar", "colorFile", ',...
        '"roiFile", "roiVar" and "targetDir", while args "trimmingThr", ',... 
        '"drawFlag" and "titleBase" are optional']);
end

if ~exist(connFile, 'file')
    error('Input arg "connFile" is not a valid file path!');
end
if ~exist(moduleFile, 'file')
    error('Input arg "moduleFile" is not a valid file path!');
end
if ~exist(colorFile, 'file')
    error('Input arg "colorFile" is not a valid file path!');
end
if ~exist(roiFile, 'file')
    error('Input arg "roiFile" is not a valid file path!');
end
if ~exist(targetDir, 'dir')
    error('Input arg "targetDir" is not a valid directory path!');
end
if ~ischar(connVar)
    error('Input arg "connVar" should be a string (variable name)!');
end
if ~ischar(moduleVar)
    error('Input arg "moduleVar" should be a string (variable name)!');
end
if ~ischar(roiVar)
    error('Input arg "roiVar" should be a string (variable name)!');
end

% check optional arguments, parse them
if ~isempty(varargin)
    for v = 1:length(varargin)
        if isnumeric(varargin{v}) && ismember(length(varargin{v}), [1 2])
            trimmingThr = varargin{v};
            for t = 1: length(trimmingThr)
                if ~ismember(trimmingThr(t), 0:0.01:0.9)
                    error('Optional input arg "trimmingThr" has value(s) outside the range 0:0.01:0.9!');
                end
            end
        elseif ischar(varargin{v}) && ismember(varargin{v}, {'draw', 'nodraw'})
            drawFlag = varargin{v};
        elseif ischar(varargin{v}) && ~ismember(varargin{v}, {'draw', 'nodraw'})
            titleBase = varargin{v};            
        else
            error(['An input arg could not be parsed as any of "trimmingThr", ',...
                '"drawFlag" or "titleBase"!']);
        end
    end
end
    
% default values if necessary
if ~exist('trimmingThr', 'var')
    trimmingThr = [0.2, 0.3];
end
if ~ exist('titleBase', 'var')
    titleBase = [];
end
if ~ exist('drawFlag', 'var')
    drawFlag = 'draw';
end

% user message
disp([char(10), 'Function circleGraphPlotWrapper is called with inputs: ',...
    char(10), 'File for the connectivity data: ', connFile,...
    char(10), 'Variable to load from connectivity data file: ', connVar,...
    char(10), 'File for module indices: ', moduleFile,...
    char(10), 'Variable to load from module indices file: ', moduleVar,...
    char(10), 'RGB color file ', colorFile,...
    char(10), 'ROI/node labels file: ', roiFile,...
    char(10), 'Variable to load from ROI/node labels file: ', roiVar,...
    char(10), 'Target dir for saving figures: ', targetDir,...
    char(10), 'Edge trimming threshold(s): ', num2str(trimmingThr),...
    char(10), 'Figure drawing flag: ', num2str(drawFlag),...
    char(10), 'Figure title base text: ', titleBase]);


%% Load data + module indices + colors

% connectivity data
data = load(connFile, connVar);
connData = data.(connVar);
% module indices / node memberships
modules = load(moduleFile, moduleVar);
modIndices = modules.(moduleVar);
% colors and ROI/node labels
load(colorFile, 'colorTriplets');
roiTmp = load(roiFile, roiVar); 
labels = roiTmp.(roiVar);
if ~iscolumn(labels) 
    labels = labels';
end

% size checks
% connData should be 3D or 4D numeric array
if ~ismember(numel(size(connData)), 3:4) || ~isnumeric(connData)
    error('Connectivity array ("connData") should be a 3D or 4D numeric array!');
end
% first two dimensions equal (square matrix of connectivity values per
% epoch)
if ~isequal(size(connData, 1), size(connData, 2))
    error('First two dimension of connectivity array should be equal (square matrix per epoch)!');
end
% get node, epoch/layer and condition/stimuli numbers
flag3d = false;
if numel(size(connData)) == 3
    flag3d = true;
    [nodeNo, ~, epochNo] = size(connData);
else
    [nodeNo, ~, epochNo, condNo] = size(connData);
end
% check if modularity indices have right dimensions    
if flag3d
    if ~isequal(size(modIndices), [nodeNo, epochNo]) || ~isnumeric(modIndices)
        error('Module array ("modIndices") should be a numeric array sized nodeNo X epochNo!');
    end
else
    if ~isequal(size(modIndices), [nodeNo, epochNo, condNo]) || ~isnumeric(modIndices)
        error('Module array ("modIndices") should be a numeric array sized nodeNo X epochNo X condNo!');
    end
end
% check labels
if ~isequal(length(labels), nodeNo)
    error('Number of ROI/node labels supplied does not match the number of nodes in connectivity data array!');
end

% user message about supplied data and module indices
disp([char(10), 'Loaded connectivity data, with size ', num2str(size(connData)),...
    char(10), 'Loaded module indices, with size ', num2str(size(modIndices)),...
    char(10), 'Loaded RGB colors for module highlighting, with ', num2str(size(colorTriplets, 1)), ' RGB triplets',...
    char(10), 'Loaded ROI/node labels, with ', num2str(length(labels)), ' elements.'])


%% New ROI/node labels in special case
% For a specific set of ROI/node labels we transform the data for 
% better plots

% expected set of labels
% roi names used most often for our EEG datasets, grouped by lobules
newLabels = {'lateralorbitofrontal L', 'medialorbitofrontal L', 'parsorbitalis L', 'parstriangularis L', 'parsopercularis L', 'rostralmiddlefrontal L', 'caudalmiddlefrontal L', 'superiorfrontal L', 'precentral L',...
    'rostralanteriorcingulate L', 'caudalanteriorcingulate L', 'posteriorcingulate L', 'isthmuscingulate L',...
    'transversetemporal L', 'superiortemporal L', 'middletemporal L', 'inferiortemporal L', 'entorhinal L', 'parahippocampal L', 'fusiform L', 'insula L',...
    'supramarginal L', 'inferiorparietal L', 'superiorparietal L', 'postcentral L', 'paracentral L', 'precuneus L',...
    'cuneus L', 'lingual L', 'pericalcarine L', 'lateraloccipital L',...
    'lateraloccipital R', 'pericalcarine R', 'lingual R', 'cuneus R',...
    'precuneus R', 'paracentral R', 'postcentral R', 'superiorparietal R', 'inferiorparietal R', 'supramarginal R',...
    'insula R', 'fusiform R', 'parahippocampal R', 'entorhinal R', 'inferiortemporal R', 'middletemporal R', 'superiortemporal R', 'transversetemporal R',...
    'isthmuscingulate R', 'posteriorcingulate R', 'caudalanteriorcingulate R', 'rostralanteriorcingulate R',...
    'precentral R', 'superiorfrontal R', 'caudalmiddlefrontal R', 'rostralmiddlefrontal R', 'parsopercularis R', 'parstriangularis R', 'parsorbitalis R', 'medialorbitofrontal R', 'lateralorbitofrontal R',...
    };
% shortened version of of usual roi names
newLabelsShort = {'latOrbFront L', 'medOrbFront L', 'parsOrb L', 'parsTriang L', 'parsOpercul L', 'rostrMidFront L', 'caudMidFront L', 'supFront L', 'precentral L',...
    'rostrAntCing L', 'caudAntCing L', 'postCing L', 'isthmusCing L',...
    'transvTemp L', 'supTemp L', 'midTemp L', 'infTemp L', 'entorhinal L', 'paraHippoc L', 'fusiform L', 'insula L',...
    'supraMarg L', 'infPar L', 'supPar L', 'postcentral L', 'paracentral L', 'precuneus L',...
    'cuneus L', 'lingual L', 'periCalc L', 'latOcc L',...
    'latOcc R', 'periCalc R', 'lingual R', 'cuneus R',...
    'precuneus R', 'paracentral R', 'postcentral R', 'supPar R', 'infPar R', 'supraMarg R',...
    'insula R', 'fusiform R', 'paraHippoc R', 'entorhinal R', 'infTemp R', 'midTemp R', 'supTemp R', 'transvTemp R',...
    'isthmusCing R', 'postCing R', 'caudAntCing R', 'rostrAntCing R',...
    'precentral R', 'supFront R', 'caudMidFront R', 'rostrMidFront R', 'parsOpercul R', 'parsTriang R', 'parsOrb R', 'medOrbFront R', 'latOrbFront R',...
    };
% amount of shift needed for proper left-right arrangement in plot
shiftLabels = 15;
% shifting common labels
newLabels = [newLabels(end-shiftLabels:end), newLabels(1:end-shiftLabels-1)]';
newLabelsShort = [newLabelsShort(end-shiftLabels:end), newLabelsShort(1:end-shiftLabels-1)]';

% get intersect of supplied labels and expected ones
intersectLabels = intersect(labels, newLabels);
intersectLabelsShort = intersect(labels, newLabelsShort);

% if the two sets match, set data transformation flag
transformFlag = false;  % label transformation flag
shortLabelsFlag = false;  % flag for long / short versions of expected labels
if isequal(intersectLabels, sort(labels))
    transformFlag = true; 
elseif isequal(intersectLabelsShort, sort(labels))
    transformFlag = true;
    shortLabelsFlag = true;
end

% user message
if transformFlag
    disp([char(10), 'The label set enables lobule highlighting in main figures.']);
else
    disp([char(10), 'The label set does not enable lobule highlighting in main figures.']);
end


%% Condition (stimulus) and epoch loops

% if connectivity array is 3d (== only one condition/stimulus)
if flag3d
    % go through epochs/layers
    for epochIdx = 1:epochNo
        
        % call helper function dealing with tansformations + exact plotting
        % call, set condIdx to empty
        callPlotting([], epochIdx, colorTriplets, connData, titleBase, targetDir,...
                labels, newLabels, newLabelsShort, shortLabelsFlag, transformFlag,...
                modIndices, trimmingThr, drawFlag)
        
    end  % for epochIdx
    
% if connectivity array is 4d (== multiple conditions/stimuli)    
else
    
    % go through conditions/stimuli
    for condIdx = 1:condNo
        % go through epochs/layers
        for epochIdx = 1:epochNo

            % call helper function dealing with tansformations + exact plotting
            % call
            callPlotting(condIdx, epochIdx, colorTriplets, connData, titleBase, targetDir,...
                    labels, newLabels, newLabelsShort, shortLabelsFlag, transformFlag,...
                    modIndices, trimmingThr, drawFlag)

        end  % for epochIdx

    end  % for condIdx
    
end  % if flag3d
                                  

end  % function


%% Helper functions

function callPlotting(condIdx, epochIdx, colorTriplets, connData, titleBase, targetDir,...
        labels, newLabels, newLabelsShort, shortLabelsFlag, transformFlag,...
        modIndices, trimmingThr, drawFlag)

    % user message
    if ~isempty(condIdx)
        disp([char(10), 'Drawing for epoch ', num2str(epochIdx), ', condition ', num2str(condIdx)]);
    else
        disp([char(10), 'Drawing for epoch ', num2str(epochIdx)]);
    end

    % epoch-level connectivity and module indices
    if ~isempty(condIdx)
        connMatrix = connData(:, :, epochIdx, condIdx);
        modIndicesVector = modIndices(:, epochIdx, condIdx);
    else
        connMatrix = connData(:, :, epochIdx);
        modIndicesVector = modIndices(:, epochIdx);
    end

    % create symmetric connectivity / adjacency matrix with zeros at diagonal
    connMatrix = triu(connMatrix, 1) + triu(connMatrix, 1)';
    connMatrix(isnan(connMatrix)) = 0;

    % title text
    if ~isempty(condIdx)
        titleText = [titleBase, ' Epoch ', num2str(epochIdx), ', cond ', num2str(condIdx)];     
    else
        titleText = [titleBase, ' Epoch ', num2str(epochIdx)];
    end

    % save files name
    if ~isempty(condIdx)
        saveFileMain = [targetDir, '/cond', num2str(condIdx),'_epoch', num2str(epochIdx), '_main.png'];
        saveFileSub = [targetDir, '/cond', num2str(condIdx), '_epoch', num2str(epochIdx), '_sub.png'];
    else
        saveFileMain = [targetDir, '/epoch', num2str(epochIdx), '_main.png'];
        saveFileSub = [targetDir, '/epoch', num2str(epochIdx), '_sub.png'];
    end

    % transform connectivity and module data in case of special label set
    if transformFlag   

        % rearrange connectivity matrix based on new ROI/node label
        % order, with long or short expected label set depending on flag
        if ~shortLabelsFlag
            [connMatrix, old2new] = matrixReorder(connMatrix, labels, newLabels);
        else
            [connMatrix, old2new] = matrixReorder(connMatrix, labels, newLabelsShort);
        end % if shortLabelsFlag

        % apply the same re-ordering to ROI/node module indices
        modIndicesVector = modIndicesVector(old2new);

        % call plotting function, label set depends on long/short
        % version flag
        if ~shortLabelsFlag
            [mainFig, subFig] = circleGraphPlot(connMatrix, modIndicesVector,...
                                    colorTriplets, trimmingThr, newLabels,... 
                                    drawFlag, titleText); 
        else
            [mainFig, subFig] = circleGraphPlot(connMatrix, modIndicesVector,...
                                    colorTriplets, trimmingThr, newLabelsShort,... 
                                    drawFlag, titleText);  
        end  % if shortLabelsFlag

    else   
        % call plotting function with supplied labels
        [mainFig, subFig] = circleGraphPlot(connMatrix, modIndicesVector,...
                                  colorTriplets, trimmingThr, labels,... 
                                  drawFlag, titleText);                                 
    end  % if transformFlag

    % save figure
    saveas(mainFig, saveFileMain);
    saveas(subFig, saveFileSub);

    % close figures
    close(mainFig); close(subFig);
        
end


% % basic data
% meanConnFile = '/home/adamb/eeg_network_pipeline/dev/edgePruningResults/alpha/avg_alpha_edgePruningInfo.mat';
% membershipFile = '/home/adamb/eeg_network_pipeline/dev/edgePruningResults/alpha/avg_alpha_edgePruningInfo_modules.mat';
% colorFile = '/home/adamb/eeg_network_pipeline/utils/colorTriplets.mat';
% load(meanConnFile, 'prunedConnAvg');
% load(membershipFile, 'memberships');
% load(colorFile, 'colorTriplets');
% 
% % select graph (and corresponding memberships)
% epochIdx = 1;
% condIdx = 1;
% g = prunedConnAvg(:, :, epochIdx, condIdx);
% m = memberships(:, epochIdx, condIdx);
% 
% % load labels / ROI names
% rois = '/home/adamb/eeg_network_pipeline/utils/roiNamesInOrder.mat';
% l = load(rois); labels = l.roisShort;


% newLabels = {'lateralorbitofrontal L', 'medialorbitofrontal L', 'parsorbitalis L', 'parstriangularis L', 'parsopercularis L', 'rostralmiddlefrontal L', 'caudalmiddlefrontal L', 'superiorfrontal L', 'precentral L',...
%     'lateralorbitofrontal R', 'medialorbitofrontal R', 'parsorbitalis R', 'parstriangularis R', 'parsopercularis R', 'rostralmiddlefrontal R', 'caudalmiddlefrontal R', 'superiorfrontal R', 'precentral R',...
%     'rostralanteriorcingulate L', 'caudalanteriorcingulate L', 'posteriorcingulate L', 'isthmuscingulate L',... 
%     'rostralanteriorcingulate R', 'caudalanteriorcingulate R', 'posteriorcingulate R', 'isthmuscingulate R',...
%     'transversetemporal L', 'superiortemporal L', 'middletemporal L', 'inferiortemporal L', 'entorhinal L', 'parahippocampal L', 'fusiform L', 'insula L',...
%     'transversetemporal R', 'superiortemporal R', 'middletemporal R', 'inferiortemporal R', 'entorhinal R', 'parahippocampal R', 'fusiform R', 'insula R',...
%     'supramarginal L', 'inferiorparietal L', 'superiorparietal L', 'postcentral L', 'paracentral L', 'precuneus L',...
%     'supramarginal R', 'inferiorparietal R', 'superiorparietal R', 'postcentral R', 'paracentral R', 'precuneus R',...
%     'lateraloccipital L', 'pericalcarine L', 'lingual L', 'cuneus L',...
%     'lateraloccipital R', 'pericalcarine R', 'lingual R', 'cuneus R'};
% 
% newLabels = {'lateralorbitofrontal L', 'medialorbitofrontal L', 'parsorbitalis L', 'parstriangularis L', 'parsopercularis L', 'rostralmiddlefrontal L', 'caudalmiddlefrontal L', 'superiorfrontal L', 'precentral L',...
%     'rostralanteriorcingulate L', 'caudalanteriorcingulate L', 'posteriorcingulate L', 'isthmuscingulate L',...
%     'transversetemporal L', 'superiortemporal L', 'middletemporal L', 'inferiortemporal L', 'entorhinal L', 'parahippocampal L', 'fusiform L', 'insula L',...
%     'supramarginal L', 'inferiorparietal L', 'superiorparietal L', 'postcentral L', 'paracentral L', 'precuneus L',...
%     'cuneus L', 'lingual L', 'pericalcarine L', 'lateraloccipital L',...
%     'lateraloccipital R', 'pericalcarine R', 'lingual R', 'cuneus R',...
%     'precuneus R', 'paracentral R', 'postcentral R', 'superiorparietal R', 'inferiorparietal R', 'supramarginal R',...
%     'insula R', 'fusiform R', 'parahippocampal R', 'entorhinal R', 'inferiortemporal R', 'middletemporal R', 'superiortemporal R', 'transversetemporal R',...
%     'isthmuscingulate R', 'posteriorcingulate R', 'caudalanteriorcingulate R', 'rostralanteriorcingulate R',...
%     'precentral R', 'superiorfrontal R', 'caudalmiddlefrontal R', 'rostralmiddlefrontal R', 'parsopercularis R', 'parstriangularis R', 'parsorbitalis R', 'medialorbitofrontal R', 'lateralorbitofrontal R',...
%     };
% 
% 
% shiftLabels = 15;
% newLabels = [newLabels(end-shiftLabels:end), newLabels(1:end-shiftLabels-1)];
% 
% % create symmetric adjacency matrix with zeros at diagonal
% g = triu(g, 1) + triu(g, 1)';
% g(isnan(g)) = 0;
% 
% [gNew, old2new] = matrixReorder(g, l.rois, newLabels);
% 
% g = gNew;
% labels = newLabels;
% m = m(old2new);
% 
% connMatrix = g; membership = m;

% trimmingThr = [0.1, 0.3];

% % just for plotting we set low values to zero
% g(g<0.2) = 0;  



% % get colors to modules
% moduleIndices = unique(m);
% colorMap = zeros(length(m), 3);
% for i = 1:length(moduleIndices)
%     colorMap(m==moduleIndices(i), :) = repmat(colorTriplets(i, :), [sum(m==moduleIndices(i)), 1]);
% end
% 
% 
% % % draw circular network figure
% % circularGraph(g,'Colormap', colorMap,'Label',labels);
% 
% % create built-in graph object
% G = graph(g, labels, 'upper');
% % edge weights into vector
% weights = G.Edges.Weight;
% % edge ending nodes into cell array
% nodesPerEdge = G.Edges.EndNodes;
% 
% % go through all modules, set different edge properties per module
% edgeColors = repmat([0.5, 0.5, 0.5], [size(weights, 1), 1]);  % preallocate variable for edge color, filled with "gray"
% edgeWidth = weights;
% moduleEdges = zeros(size(weights, 1), length(moduleIndices));
% for i = 1:length(moduleIndices)
%     moduleNodes = labels(m == moduleIndices(i));
%     moduleEdges(:, i) = ismember(nodesPerEdge(:, 1), moduleNodes) & ismember(nodesPerEdge(:, 2), moduleNodes);
%     edgeColors(logical(moduleEdges(:, i)), :) = repmat(colorTriplets(i, :), [sum(moduleEdges(:, i)), 1]);
%     edgeWidth(logical(moduleEdges(:, i))) = weights(logical(moduleEdges(:, i)))*10;
% end
% 
% outModEdgeIdx = ismember(edgeColors, [0.5, 0.5, 0.5], 'rows');
% edgeStyle = repmat({'-'}, [size(weights, 1), 1]);
% edgeStyle(outModEdgeIdx) = repmat({'none'}, [sum(outModEdgeIdx, 1), 1]);
% 
% % create base graph plot
% H = G.plot('Layout', 'circle',... 
%     'LineWidth', edgeWidth,... 
%     'EdgeColor', edgeColors,... 
%     'EdgeAlpha', 0.3,... 
%     'NodeColor', colorMap,...
%     'MarkerSize', 10,...
%     'LineStyle', edgeStyle);
% 
% % highlight a module
% % nodes
% modNodes = labels(m==0);
% highlight(H, modNodes, 'MarkerSize', 10, 'NodeColor', colorTriplets(2,:));
% % edges
% % get edge indices for connections inside the module
% modG = subgraph(G, modNodes);
% subgNodes = modG.Edges.EndNodes;
% subgWeights = modG.Edges.Weight;
% for subedge = 1:size(subgNodes, 1)
%     highlight(H, subgNodes(subedge, 1), subgNodes(subedge, 2), 'LineWidth', subgWeights(subedge)*12, 'EdgeColor', colorTriplets(2,:));
% end



