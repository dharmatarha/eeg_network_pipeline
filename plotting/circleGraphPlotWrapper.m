function circleGraphPlotWrapper(connFile, connVar, moduleFile, moduleVar, colorFile, roiFile, targetDir, varargin)
%% Wrapper for calling circleGraphPlot on a set of connectivity matrices
% E.g. plotting all epochs in a subject's data. 
%
% USAGE circleGraphPlotWrapper(connFile, 
%                               connVar, 
%                               moduleFile, 
%                               moduleVar, 
%                               colorFile, 
%                               roiFile, 
%                               targetDir, 
%                               trimmingThr=[0.2, 0.3],... 
%                               drawFlag=1, 
%                               titleBase=[])
%
% It save all plots generated by circleGraphPlot out in png format to
% "targetDir". Optional inputs are passed on to circleGraphPlot at each
% function call. 
%
% Mandatory inputs:
% connFile      - String, path to a file containing the relevant
%           connectivity array. Typically the output of edgePruning.m or 
%           getMeanConn.m (the later performed on a set of edgePruning.m 
%           results) 
% connVar       - String, name of the connectivity array variable. The
%           array, as with other functions in this repo, is expected to
%           contain a set of connectivity matrices, each defined by the
%           first two dimensions. Third and fourth dimensions are expected
%           to refer to epochs and conditions (stimuli). 
% moduleFile    - String, path to a file containing the modules identified
%           in the connectivity array "connVar".  
% moduleVar     - String, name of the module indices array. Expected to be
%           a numerical array with the first dimension matching the 
%           number of nodes/ROIs, the second and third dimension the 
%           epochs and conditions (stimuli).
% colorFile     - String, path to file containing a "colorTriplets" matrix
%           variable. The matrix is expected to have three columns,
%           with each row defining an RGB color. Used for highlighting
%           different modules in plots.
% roiFile     - String, path to file containing a "rois" cell array
%           variable holding the node/ROI labels. 
% targetDir     - String, path to a folder, used for saving out all
%           generated plots.
%
%
% Optional inputs:
% trimmingThr   - Numeric vector with one or two elements. Edge trimming 
%           treshold that is passed on to circleGraphPlot. Value(s)
%           must be in range [0:0.01:0.9]. Defaults to [0.2, 0.3].
% drawFlag      - String, one of {'draw', 'nodraw'}. Passed on to circleGraphPlot.
%           Flag for displaying the plot (='draw') or only returning 
%           the plot object handle ('nodraw'). Defaults to 'draw' (display plot).
% titleBase     - String, title text for each figure generated. "titleBase"
%           is always amended by the epoch and conditino number. Defaults to
%           [].
%
%



%% Input checks

if ~ismember(nargin, 7:10)
    error(['Function circleGraphPlotWrapper requires input args: ',...
        '"connFile", "connVar", "moduleFile", "moduleVar", "colorFile", ',...
        '"roiFile" and "targetDir", while args "trimmingThr", ',... 
        '"drawFlag" and "titleBase" are optional']);
end

if ~exist(connFile, 'file')
    error('Input arg "connFile" is not a valid file path!');
end
if ~exist(moduleFile, 'file')
    error('Input arg "moduleFile" is not a valid file path!');
end
if ~exist(colorFile, 'file')
    error('Input arg "colorFile" is not a valid file path!');
end
if ~exist(roiFile, 'file')
    error('Input arg "roiFile" is not a valid file path!');
end
if ~exist(targetDir, 'dir')
    error('Input arg "targetDir" is not a valid directory path!');
end
if ~ischar(connVar)
    error('Input arg "connVar" should be a string (variable name)!');
end
if ~ischar(moduleVar)
    error('Input arg "moduleVar" should be a string (variable name)!');
end

% check optional arguments, parse them
if ~isempty(varargin)
    for v = 1:length(varargin)
        if isnumeric(varargin{v}) && ismember(length(varargin{v}), [1 2])
            trimmingThr = varargin{v};
            for t = 1: length(trimmingThr)
                if ~ismember(trimmingThr(t), 0:0.01:0.9)
                    error('Optional input arg "trimmingThr" has value(s) outside 0:0.01:0.9!');
                end
            end
        elseif ischar(varargin{v}) && ismember(varargin{v}, {'draw', 'nodraw'})
            drawFlag = varargin{v};
        elseif ischar(varargin{v}) && ~ismember(varargin{v}, {'draw', 'nodraw'})
            titleBase = varargin{v};            
        else
            error(['An input arg could not be parsed as any of "trimmingThr", ',...
                '"drawFlag" or "titleBase"!']);
        end
    end
end
    
% default values if necessary
if ~exist('trimmingThr', 'var')
    trimmingThr = [0.2, 0.3];
end
if ~ exist('titleBase', 'var')
    titleBase = [];
end
if ~ exist('drawFlag', 'var')
    drawFlag = 'draw';
end

% user message
disp([char(10), 'Function circleGraphPlotWrapper is called with inputs: ',...
    char(10), 'File for the connectivity data: ', connFile,...
    char(10), 'Variable to load from connectivity data file: ', connVar,...
    char(10), 'File for module indices: ', moduleFile,...
    char(10), 'Variable to load from module indices file: ', moduleVar,...
    char(10), 'RGB color file ', colorFile,...
    char(10), 'ROI/node labels file: ', roiFile,...
    char(10), 'Target dir for saving figures: ', targetDir,...
    char(10), 'Edge trimming threshold(s): ', num2str(trimmingThr),...
    char(10), 'Figure drawing flag: ', num2str(drawFlag),...
    char(10), 'Figure title base text: ', titleBase]);



%% Load data + module indices + colors

% connectivity data
data = load(connFile, connVar);
connData = data.(connVar);
% module indices / node memberships
modules = load(moduleFile, moduleVar);
modIndices = modules.(moduleVar);
% colors and ROI/node labels
load(colorFile, 'colorTriplets');
load(roiFile, 'rois'); labels = rois;

% sanity checks
if ~isequal(size(connData, 1), size(connData, 2))
    error('First two dimension of connectivity array should be equal (square matrix per epoch)!');
end
if ~isequal(size(modIndices, 1), size(connData, 1))
    error('First dimension of module array does not match first dimension of connectivity data array!');
end
if ~isequal(length(rois), size(connData, 1))
    error('Number of ROI/node labels supplied does not match the number of nodes in connectivity data array (its first dimension)!');
end

% user message about supplied data and module indices
disp([char(10), 'Loaded connectivity data, with size ', num2str(size(connData)),...
    char(10), 'Loaded module indices, with size ', num2str(size(modIndices)),...
    char(10), 'Loaded RGB colors for module highlighting, with ', num2str(size(colorTriplets, 1)), ' RGB triplets',...
    char(10), 'Loaded ROI/node labels, with ', num2str(length(labels)), ' elements.'])


%% New ROI/node labels in special case
% For a specific set of ROI/node labels we transform the data for 
% better plots

% expected set of labels
newLabels = {'lateralorbitofrontal L', 'medialorbitofrontal L', 'parsorbitalis L', 'parstriangularis L', 'parsopercularis L', 'rostralmiddlefrontal L', 'caudalmiddlefrontal L', 'superiorfrontal L', 'precentral L',...
    'rostralanteriorcingulate L', 'caudalanteriorcingulate L', 'posteriorcingulate L', 'isthmuscingulate L',...
    'transversetemporal L', 'superiortemporal L', 'middletemporal L', 'inferiortemporal L', 'entorhinal L', 'parahippocampal L', 'fusiform L', 'insula L',...
    'supramarginal L', 'inferiorparietal L', 'superiorparietal L', 'postcentral L', 'paracentral L', 'precuneus L',...
    'cuneus L', 'lingual L', 'pericalcarine L', 'lateraloccipital L',...
    'lateraloccipital R', 'pericalcarine R', 'lingual R', 'cuneus R',...
    'precuneus R', 'paracentral R', 'postcentral R', 'superiorparietal R', 'inferiorparietal R', 'supramarginal R',...
    'insula R', 'fusiform R', 'parahippocampal R', 'entorhinal R', 'inferiortemporal R', 'middletemporal R', 'superiortemporal R', 'transversetemporal R',...
    'isthmuscingulate R', 'posteriorcingulate R', 'caudalanteriorcingulate R', 'rostralanteriorcingulate R',...
    'precentral R', 'superiorfrontal R', 'caudalmiddlefrontal R', 'rostralmiddlefrontal R', 'parsopercularis R', 'parstriangularis R', 'parsorbitalis R', 'medialorbitofrontal R', 'lateralorbitofrontal R',...
    };
shiftLabels = 15;
newLabels = [newLabels(end-shiftLabels:end), newLabels(1:end-shiftLabels-1)];

% get intersect of supplied labels and expected ones
c = intersect(labels, newLabels);

% if the two sets match, set data transformation flag
if isequal(c, labels)
    transformFlag = 1;  % transformation flag
else
    transformFlag = 0;
end

% user message
if transformFlag
    disp([char(10), 'The label set enables lobule highlighting in main figures.']);
else
    disp([char(10), 'The label set does not enable lobule highlighting in main figures.']);
end


%% Condition (stimulus) and epoch loops

epochNo = size(connData, 3);
condNo = size(connData, 4);

for condIdx = 1:condNo
    
    for epochIdx = 1:epochNo
        
        % user message
        disp([char(10), 'Drawing for epoch ', num2str(epochIdx), ', condition ', num2str(condIdx)]);
        
        % epoch-level connectivity and module indices
        connMatrix = connData(:, :, epochIdx, condIdx);
        modIndicesVector = modIndices(:, epochIdx, condIdx);

        % create symmetric connectivity / adjacency matrix with zeros at diagonal
        connMatrix = triu(connMatrix, 1) + triu(connMatrix, 1)';
        connMatrix(isnan(connMatrix)) = 0;
        
        % title text
        titleText = [titleBase, ' Epoch ', num2str(epochIdx), ', cond ', num2str(condIdx)];     
        
        % save files name
        saveFileMain = [targetDir, '/epoch', num2str(epochIdx), '_cond', num2str(condIdx), '_main.png'];
        saveFileSub = [targetDir, '/epoch', num2str(epochIdx), '_cond', num2str(condIdx), '_sub.png'];
        
        % transform connectivity and module data in case of special label set
        if transformFlag   
            
            % rearrange connectivity matrix based on new ROI/node label
            % order
            [connMatrix, old2new] = matrixReorder(connMatrix, labels, newLabels);
            % apply the same re-ordering to ROI/node module indices
            modIndicesVector = modIndicesVector(old2new);
            
            % call plotting function
            [mainFig, subFig] = circleGraphPlot(connMatrix, modIndicesVector,...
                                      colorTriplets, trimmingThr, newLabels,... 
                                      drawFlag, titleText);        
                                  
        else    
            % call plotting function
            [mainFig, subFig] = circleGraphPlot(connMatrix, modIndicesVector,...
                                      colorTriplets, trimmingThr, labels,... 
                                      drawFlag, titleText);                                 
        end
        
        % save figure
        saveas(mainFig, saveFileMain);
        saveas(subFig, saveFileSub);
        
        % close figures
        close(mainFig); close(subFig);
        
    end
    
end
                                  

return


% % basic data
% meanConnFile = '/home/adamb/eeg_network_pipeline/dev/edgePruningResults/alpha/avg_alpha_edgePruningInfo.mat';
% membershipFile = '/home/adamb/eeg_network_pipeline/dev/edgePruningResults/alpha/avg_alpha_edgePruningInfo_modules.mat';
% colorFile = '/home/adamb/eeg_network_pipeline/utils/colorTriplets.mat';
% load(meanConnFile, 'prunedConnAvg');
% load(membershipFile, 'memberships');
% load(colorFile, 'colorTriplets');
% 
% % select graph (and corresponding memberships)
% epochIdx = 1;
% condIdx = 1;
% g = prunedConnAvg(:, :, epochIdx, condIdx);
% m = memberships(:, epochIdx, condIdx);
% 
% % load labels / ROI names
% rois = '/home/adamb/eeg_network_pipeline/utils/roiNamesInOrder.mat';
% l = load(rois); labels = l.roisShort;


% newLabels = {'lateralorbitofrontal L', 'medialorbitofrontal L', 'parsorbitalis L', 'parstriangularis L', 'parsopercularis L', 'rostralmiddlefrontal L', 'caudalmiddlefrontal L', 'superiorfrontal L', 'precentral L',...
%     'lateralorbitofrontal R', 'medialorbitofrontal R', 'parsorbitalis R', 'parstriangularis R', 'parsopercularis R', 'rostralmiddlefrontal R', 'caudalmiddlefrontal R', 'superiorfrontal R', 'precentral R',...
%     'rostralanteriorcingulate L', 'caudalanteriorcingulate L', 'posteriorcingulate L', 'isthmuscingulate L',... 
%     'rostralanteriorcingulate R', 'caudalanteriorcingulate R', 'posteriorcingulate R', 'isthmuscingulate R',...
%     'transversetemporal L', 'superiortemporal L', 'middletemporal L', 'inferiortemporal L', 'entorhinal L', 'parahippocampal L', 'fusiform L', 'insula L',...
%     'transversetemporal R', 'superiortemporal R', 'middletemporal R', 'inferiortemporal R', 'entorhinal R', 'parahippocampal R', 'fusiform R', 'insula R',...
%     'supramarginal L', 'inferiorparietal L', 'superiorparietal L', 'postcentral L', 'paracentral L', 'precuneus L',...
%     'supramarginal R', 'inferiorparietal R', 'superiorparietal R', 'postcentral R', 'paracentral R', 'precuneus R',...
%     'lateraloccipital L', 'pericalcarine L', 'lingual L', 'cuneus L',...
%     'lateraloccipital R', 'pericalcarine R', 'lingual R', 'cuneus R'};
% 
% newLabels = {'lateralorbitofrontal L', 'medialorbitofrontal L', 'parsorbitalis L', 'parstriangularis L', 'parsopercularis L', 'rostralmiddlefrontal L', 'caudalmiddlefrontal L', 'superiorfrontal L', 'precentral L',...
%     'rostralanteriorcingulate L', 'caudalanteriorcingulate L', 'posteriorcingulate L', 'isthmuscingulate L',...
%     'transversetemporal L', 'superiortemporal L', 'middletemporal L', 'inferiortemporal L', 'entorhinal L', 'parahippocampal L', 'fusiform L', 'insula L',...
%     'supramarginal L', 'inferiorparietal L', 'superiorparietal L', 'postcentral L', 'paracentral L', 'precuneus L',...
%     'cuneus L', 'lingual L', 'pericalcarine L', 'lateraloccipital L',...
%     'lateraloccipital R', 'pericalcarine R', 'lingual R', 'cuneus R',...
%     'precuneus R', 'paracentral R', 'postcentral R', 'superiorparietal R', 'inferiorparietal R', 'supramarginal R',...
%     'insula R', 'fusiform R', 'parahippocampal R', 'entorhinal R', 'inferiortemporal R', 'middletemporal R', 'superiortemporal R', 'transversetemporal R',...
%     'isthmuscingulate R', 'posteriorcingulate R', 'caudalanteriorcingulate R', 'rostralanteriorcingulate R',...
%     'precentral R', 'superiorfrontal R', 'caudalmiddlefrontal R', 'rostralmiddlefrontal R', 'parsopercularis R', 'parstriangularis R', 'parsorbitalis R', 'medialorbitofrontal R', 'lateralorbitofrontal R',...
%     };
% 
% 
% shiftLabels = 15;
% newLabels = [newLabels(end-shiftLabels:end), newLabels(1:end-shiftLabels-1)];
% 
% % create symmetric adjacency matrix with zeros at diagonal
% g = triu(g, 1) + triu(g, 1)';
% g(isnan(g)) = 0;
% 
% [gNew, old2new] = matrixReorder(g, l.rois, newLabels);
% 
% g = gNew;
% labels = newLabels;
% m = m(old2new);
% 
% connMatrix = g; membership = m;

% trimmingThr = [0.1, 0.3];

% % just for plotting we set low values to zero
% g(g<0.2) = 0;  



% % get colors to modules
% moduleIndices = unique(m);
% colorMap = zeros(length(m), 3);
% for i = 1:length(moduleIndices)
%     colorMap(m==moduleIndices(i), :) = repmat(colorTriplets(i, :), [sum(m==moduleIndices(i)), 1]);
% end
% 
% 
% % % draw circular network figure
% % circularGraph(g,'Colormap', colorMap,'Label',labels);
% 
% % create built-in graph object
% G = graph(g, labels, 'upper');
% % edge weights into vector
% weights = G.Edges.Weight;
% % edge ending nodes into cell array
% nodesPerEdge = G.Edges.EndNodes;
% 
% % go through all modules, set different edge properties per module
% edgeColors = repmat([0.5, 0.5, 0.5], [size(weights, 1), 1]);  % preallocate variable for edge color, filled with "gray"
% edgeWidth = weights;
% moduleEdges = zeros(size(weights, 1), length(moduleIndices));
% for i = 1:length(moduleIndices)
%     moduleNodes = labels(m == moduleIndices(i));
%     moduleEdges(:, i) = ismember(nodesPerEdge(:, 1), moduleNodes) & ismember(nodesPerEdge(:, 2), moduleNodes);
%     edgeColors(logical(moduleEdges(:, i)), :) = repmat(colorTriplets(i, :), [sum(moduleEdges(:, i)), 1]);
%     edgeWidth(logical(moduleEdges(:, i))) = weights(logical(moduleEdges(:, i)))*10;
% end
% 
% outModEdgeIdx = ismember(edgeColors, [0.5, 0.5, 0.5], 'rows');
% edgeStyle = repmat({'-'}, [size(weights, 1), 1]);
% edgeStyle(outModEdgeIdx) = repmat({'none'}, [sum(outModEdgeIdx, 1), 1]);
% 
% % create base graph plot
% H = G.plot('Layout', 'circle',... 
%     'LineWidth', edgeWidth,... 
%     'EdgeColor', edgeColors,... 
%     'EdgeAlpha', 0.3,... 
%     'NodeColor', colorMap,...
%     'MarkerSize', 10,...
%     'LineStyle', edgeStyle);
% 
% % highlight a module
% % nodes
% modNodes = labels(m==0);
% highlight(H, modNodes, 'MarkerSize', 10, 'NodeColor', colorTriplets(2,:));
% % edges
% % get edge indices for connections inside the module
% modG = subgraph(G, modNodes);
% subgNodes = modG.Edges.EndNodes;
% subgWeights = modG.Edges.Weight;
% for subedge = 1:size(subgNodes, 1)
%     highlight(H, subgNodes(subedge, 1), subgNodes(subedge, 2), 'LineWidth', subgWeights(subedge)*12, 'EdgeColor', colorTriplets(2,:));
% end



